# Comunicazione Sincrona

La comunicazione sincrona è un tipo di interazione tra sistemi, applicazioni o processi in cui le parti coinvolte devono essere attive nello stesso momento per poter scambiarsi dati o informazioni in tempo reale. Il chiamante rimane "bloccato" finchè non riceve risposta.

Esiste anche un tipo di comunicazione detta asincrona, in cui sistemi, applicazioni o processi interagiscono tra di loro senza attendere immediatamente una risposta. Il destinatario può ricevere e processare i dati in un momento successivo, permettendo al mittente di continuare il proprio lavoro senza blocchi.

Problemi generici delle comunicazioni sincrone:

- Serializzazione
- Accoppiamento spaziale
- Accoppiamento temporale
- Accoppiamento delle API
- Over-fetching
- Under-fetching
- Esaustione della memoria

## REST (Representational State Transfer)

REST è uno stile architetturale per creare API che permette a client e server di comunicare tramite il protocollo HTTP, usando risorse identificate da URL.  
Le API REST funzionano tipicamente in modo sincrono:

1. Il client invia una richiesta HTTP al server.  
   *GET* per recuperare informazioni da una risorsa  
   *POST* per creare una nuova risorsa  
   *PUT* per aggiornare una risorsa esistente  
   *DELETE* per eliminare una risorsa esistente  
   
2. Il server elabora la richiesta e restituisce subito una risposta formata da status code e dati.  
   Gli status code sono il linguaggio con cui il server comunica al client se una richiesta è andata a buon fine o meno.  
   Ogni codice appartiene a una classe, determinata dalla prima cifra.

   2xx – Successo  
   La richiesta è stata ricevuta, compresa ed elaborata con successo.  
   *200 OK* → richiesta andata a buon fine  
   *201 Created* → nuova risorsa creata  

   4xx – Errori del client  
   La richiesta contiene errori o è malformata.  
   *400 Bad Request* → richiesta non valida  
   *404 Not Found* → risorsa non trovata  

   5xx – Errori del server  
   Il server ha ricevuto la richiesta, ma non è riuscito a gestirla.  
   *500 Internal Server Error* → errore generico  
   *503 Service Unavailable* → servizio momentaneamente non disponibile  
   *504 Gateway Timeout* → il server non ha risposto in tempo  
   
Fino a quando il client non riceve la risposta, resta bloccato in attesa.

## GRAPHQL

GraphQL è un linguaggio di interrogazione per API, non un'architettura come REST che stabilisce principi generali di comunicazione, poiché definisce come i client possono richiedere e manipolare i dati in modo flessibile, evitando problemi di over-fetching e under-fetching. 

Le richieste al server possono essere fatte principalmente sottoforma di **query** in sola lettura per recuperare i dati dal server e **mutazioni** per modificare e creare dati sul server.

Vantaggi
- unico endpoint */graphql* a cui faccio richieste stile SQL
- client può specificare esattamente quali dati vuole ottenere in un'unica richiesta. Il server risponde con un JSON con soli i dati richiesti  
      → no underfetching e overfetching
- sistema di tipizzazione che consente di definire chiaramente la struttura dei dati e convalidare le query in fase di compilazione
- documentazione API automatica che porta a una robustezza lato client
- robustezza lato server, l'API può evolvere senza causare problemi ai client, non necessità del controllo di versione

## GRAPHQL vs REST

1. ARCHITETTURA  
   **R**: definizione delle risorse con gli URL e utilizzo di metodi HTTP standard  
   **G**: unico endpoint per tutte le richieste

2. RICHIESTE  
   **R**: ogni endpoint è associato ad una risorsa specifica, le risposte sono fisse e possono includere dati non necessari  
   -> underfetching e overfetching  
   **G**: specificare esattamente quali dati si desiderano riducendo i dati non necessari e si possono richiedere più risorse con una sola chiamata  
          -> flessibilità, efficienza, non sovraccarica la rete

4. SCALABILITÀ  
   **R**: più semplice per API semplici con poche risorse e relazioni  
   **G**: riesce a gestire relazioni complesse senza utilizzo di endpoint specifici. Richiede una maggiore pianificazione iniziale, è preferito per applicazioni             moderne e complesse

5. VERSIONING  
   **R**: richiede il controllo di versione delle API per gestire le modifiche  
   **G**: non richiede il controllo di versione, le modifiche possono essere gestite tramite lo schema senza interrompere le query esistenti

6. CACHING  
   **R**: i browser hanno cache integrate quindi gli endpoint fissi permettono di salvare automaticamente le risposte  
   **G**: gestione della cache è più complessa perchè ho un unico endpoint a cui poter fare diverse richieste, richiede tecniche e strumenti specifici





